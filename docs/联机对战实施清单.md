# 联机对战功能实施清单

## 阶段 1: 网络基础设施 (1-2周)

### 1.1 NetworkManager 完善
- [ ] 复制 `NETWORK_MANAGER_CODE_EXAMPLE.gd` 内容到 `scenes/network/network_manager.gd`
- [ ] 测试服务器创建功能
- [ ] 测试客户端连接功能
- [ ] 实现心跳检测
- [ ] 实现断线重连基础逻辑
- [ ] 添加到 Autoload: `project.godot` 中注册 NetworkManager

### 1.2 SyncManager 创建
- [ ] 创建 `scenes/network/sync_manager.gd`
- [ ] 实现定时同步机制 (20次/秒)
- [ ] 实现球状态同步接口
- [ ] 实现玩家状态同步接口
- [ ] 添加到 Autoload

### 1.3 联机大厅 UI
- [ ] 创建 `scenes/screens/network_lobby_screen.tscn`
- [ ] 添加创建房间按钮
- [ ] 添加加入房间按钮和 IP 输入框
- [ ] 添加玩家列表显示
- [ ] 添加开始游戏按钮（仅房主可见）
- [ ] 创建 `scenes/screens/network_lobby_screen.gd` 逻辑脚本
- [ ] 连接 NetworkManager 信号
- [ ] 实现玩家列表更新

### 1.4 主菜单改造
- [ ] 修改 `scenes/screens/main_menu_screen.gd`
- [ ] 添加"联机对战"选项
- [ ] 点击联机选项跳转到大厅界面
- [ ] 测试界面跳转流程

---

## 阶段 2: 核心系统改造 (2-3周)

### 2.1 GameManager 网络化
- [ ] 在 `scenes/game_manager/game_manager.gd` 添加 `GameMode` 枚举
- [ ] 添加 `is_network_authority` 标识
- [ ] 修改 `switch_state()` 添加网络同步
- [ ] 创建 `@rpc` 方法 `_sync_game_state()`
- [ ] 修改比分更新逻辑，添加网络同步
- [ ] 创建 `@rpc` 方法 `_sync_score()`
- [ ] 修改时间更新逻辑（仅服务器计时）
- [ ] 测试游戏状态同步

### 2.2 GameStateData 序列化
- [ ] 在 `scenes/game_manager/game_state/game_state_data.gd` 添加 `to_dict()` 方法
- [ ] 添加 `from_dict()` 静态方法
- [ ] 测试数据序列化和反序列化

### 2.3 Player 网络控制
- [ ] 在 `scenes/characters/player.gd` 添加网络属性
  - [ ] `network_peer_id`
  - [ ] `is_local_player`
  - [ ] `is_network_controlled`
  - [ ] `network_position`, `network_velocity`, `network_state`
- [ ] 修改 `_process()` 分离本地/网络/AI 逻辑
- [ ] 创建 `handle_local_input()` 方法
- [ ] 创建 `apply_network_state()` 方法
- [ ] 创建 `@rpc` 方法 `_receive_player_input()`
- [ ] 创建 `@rpc` 方法 `_sync_player_input()`
- [ ] 创建 `sync_state_to_network()` 方法
- [ ] 创建 `@rpc` 方法 `_apply_network_state()`
- [ ] 测试玩家输入同步

### 2.4 PlayerState 状态同步
- [ ] 修改关键状态（射门、传球、铲球）添加网络同步
- [ ] 在 `PlayerStateShooting` 添加 `@rpc _sync_shoot()`
- [ ] 在 `PlayerStatePassing` 添加 `@rpc _sync_pass()`
- [ ] 在 `PlayerStateTackling` 添加 `@rpc _sync_tackle()`
- [ ] 测试状态切换同步

### 2.5 Ball 权威服务器控制
- [ ] 在 `scenes/ball/ball.gd` 添加网络属性
  - [ ] `is_network_authority`
  - [ ] `network_position`, `network_velocity`, `network_height`
  - [ ] `network_carrier_id`
- [ ] 修改 `_process()` 分离服务器/客户端逻辑
- [ ] 创建 `sync_to_clients()` 方法
- [ ] 创建 `@rpc` 方法 `_apply_ball_state()`
- [ ] 创建 `apply_network_state()` 方法（插值）
- [ ] 修改 `shoot()` 方法添加网络同步
- [ ] 创建 `@rpc` 方法 `_sync_shoot()`
- [ ] 修改 `pass_to()` 方法添加网络同步
- [ ] 创建 `@rpc` 方法 `_sync_pass()`
- [ ] 测试球物理同步

### 2.6 ActorsContainer 网络生成
- [ ] 修改 `scenes/actors_container.gd` 的 `_ready()`
- [ ] 添加 `spawn_network_players()` 方法
- [ ] 添加 `spawn_network_player()` 方法
- [ ] 实现网络玩家分配逻辑
- [ ] 测试网络玩家生成

### 2.7 KeyUtils 网络适配
- [ ] 在 `utils/key_utils.gd` 添加 `network_inputs` 字典
- [ ] 创建 `inject_network_input()` 方法
- [ ] 创建 `is_action_pressed_network()` 方法
- [ ] 创建 `get_input_vector_network()` 方法
- [ ] 测试网络输入注入

---

## 阶段 3: 状态同步优化 (1-2周)

### 3.1 客户端预测
- [ ] 实现本地玩家立即响应输入
- [ ] 保存输入历史记录
- [ ] 实现状态回滚机制
- [ ] 测试预测准确性

### 3.2 服务器和解
- [ ] 服务器验证客户端状态
- [ ] 检测状态不一致
- [ ] 发送校正数据
- [ ] 客户端应用校正
- [ ] 测试和解效果

### 3.3 插值和外推
- [ ] 实现位置插值（lerp）
- [ ] 实现速度外推
- [ ] 调整插值系数
- [ ] 测试平滑度

### 3.4 延迟补偿
- [ ] 记录网络延迟
- [ ] 实现时间戳同步
- [ ] 调整同步频率
- [ ] 测试不同延迟下的表现

---

## 阶段 4: 完善和优化 (1-2周)

### 4.1 断线重连
- [ ] 检测断线事件
- [ ] 保存游戏状态
- [ ] 实现重连逻辑
- [ ] 恢复游戏状态
- [ ] 测试断线重连

### 4.2 错误处理
- [ ] 添加连接失败提示
- [ ] 添加网络错误提示
- [ ] 添加超时处理
- [ ] 测试各种错误场景

### 4.3 性能优化
- [ ] 优化同步频率
- [ ] 压缩网络数据
- [ ] 减少不必要的 RPC 调用
- [ ] 性能测试和调优

### 4.4 作弊防护
- [ ] 服务器验证所有输入
- [ ] 检测异常行为
- [ ] 限制输入频率
- [ ] 测试作弊检测

---

## 测试清单

### 功能测试
- [ ] 创建房间成功
- [ ] 加入房间成功
- [ ] 玩家列表正确显示
- [ ] 开始游戏正常
- [ ] 玩家移动同步
- [ ] 射门动作同步
- [ ] 传球动作同步
- [ ] 球物理同步
- [ ] 进球判定同步
- [ ] 比分更新同步
- [ ] 游戏结束同步

### 网络测试
- [ ] 本地网络 (0ms 延迟)
- [ ] 低延迟 (50ms)
- [ ] 中延迟 (100ms)
- [ ] 高延迟 (200ms)
- [ ] 极高延迟 (500ms)
- [ ] 丢包测试 (5%, 10%)
- [ ] 断线重连测试

### 压力测试
- [ ] 2 人对战稳定性
- [ ] 长时间运行 (30分钟+)
- [ ] 快速操作响应
- [ ] 内存占用正常
- [ ] CPU 占用正常

---

## 已知问题和注意事项

### 注意事项
1. **RPC 权限**: 使用 `@rpc("authority")` 确保只有服务器能广播状态
2. **可靠性**: 关键事件用 `"reliable"`，位置同步用 `"unreliable"`
3. **插值系数**: 需要根据实际延迟调整 lerp 系数 (0.3-0.5)
4. **同步频率**: 20次/秒是推荐值，可根据带宽调整
5. **AI 逻辑**: 确保 AI 只在服务器运行，避免重复计算

### 常见问题
1. **Q: 为什么球会抖动？**
   - A: 插值系数太小或同步频率太低，增加插值系数或提高同步频率

2. **Q: 为什么操作有延迟？**
   - A: 未实现客户端预测，本地玩家应立即响应输入

3. **Q: 为什么状态不一致？**
   - A: 客户端执行了物理计算，确保只有服务器计算物理

4. **Q: 为什么带宽占用高？**
   - A: 同步频率过高或数据未压缩，优化同步策略

---

**最后更新**: 2026-02-11  
**版本**: v1.0

